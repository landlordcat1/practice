#### 一、概述
##### 虚拟机把描述类的数据从Class文件加载到内存，并从数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
##### 在Java语言里，类型的加载、连接和初始化给过程都是在程序运行期间完成的，
##### ①在实际情况中，每个Class文件都有可能代表着Java语言文件中的一个类或者接口，后文中直接对类的描述都包括了类和接口的可能性，而由于类和接口需要分开描述的场景会特别指明。
 ##### ②本章中提到的所有Class文件并非指某个存在于具体磁盘中的文件，这里所说的“Class文件”应当是一串二进制的字节流，无论以任何形式的都可以。
#### 二、类加载的机制
##### 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备和解析3个部分统称为连接，这7个阶段的发生顺序如图所示。
![image](http://i.caigoubao.cc/625949/timg.jpg)
##### 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种过程按部就班地开始，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（被称为动态绑定和晚期绑定）。什么情况下需要开始类加载过程的第一个阶段：Java虚拟机规范中并没有进行强制约束，这点交给虚拟机的具体实现来把握。
##### 在初始化阶段，虚拟机规范则是在严格规范了有且只有五种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
###### 1）遇到new、getstatic、putstatic或invokestatic这四个字节码指令时，如果类没有进行过初始化，则需要触发其初始化。
###### 2）使用Java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要进行初始化。
###### 3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
###### 4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
###### 5）当使用JDK1.7的动态语言支持时，如果一个Java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putstatic、REF_invokeStatic的方法句柄，并且这个方法对应的类没有进行初始化。则需要先触发其初始化。
==在一个类中进行初始化的时候，要求其父类全部都已经初始化过了，但是一个接口在初始化的时候，并不要求父接口全部都完成了初始化，只有在真正用到了父接口的时候。==

#### 三、类加载的过程
**<font color=pink size=4>加载</font>**
##### "加载"是"类加载"过程的一个阶段，在加载阶段，虚拟机需要完成一下3件事情：
##### 1） 通过一个类的全限定名来获取定义此类的二进制字节流。
##### 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
##### 3）在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

==任何类在被系统使用时都会为其创建一个且仅有一个class对象。==

##### 相当于累加载的其他阶段，一个非数组类的加载阶段（准确来说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的是，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以用户自定义的类加载器去完成，开发人员可以通过自定义自己的类加载器去控制字节流的获取方式。
 
 ##### 对于数组类而言，情况就有所不同，数组类本身不通过类加载器来创建，它是由Java虚拟机直接创建的。但数字类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去实现，一个数组类的创建就要遵循以下规则。
-  如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。
-  如果数组的类型不是引用类型，Java虚拟机会把数组C标价为来引导类加载器失联。
-  数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组的默认类型会默认为public。
###### 加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。虚拟机规范未规定此区域的具体数据结构。然后再内存中实例化一个Java.lang.class类的对象，这个对象作为程序访问方法区中的这些类型数组的外部入口。
**加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在夹在阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。**

**<font color=pink size=4>验证</font>**

##### 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成以下四个阶段的检验动作：文件格式检验、元数据验证、字节码验证、符号验证引用。
###### 文件格式验证：
要验证字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理。
###### 元数据验证：
对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下：
- 这个类是否有父类
- 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
- 类中的字段、方法是否与父类产生矛盾
###### 字节码验证
主要是通过数据流和控制流分析，确定语义是合法的，符合逻辑的。
###### 符号引用验证
最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段----解析阶段中发生。符号引用验证可以看做对类自身以外的信息进行匹配校验，通常需要校验一下 内容：
- 符号引用中通过字符串描述的全限定名是否能找到相应的类。
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
- 符号引用中的类、字段、方法的访问性是否被当前了就所访问。

**<font color=pink size=4>准备</font>**

准备阶段是正式为类变量分配内存并设置类变量初始值得阶段，这些变量所使用的的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在堆中。


```
public static int value=123；//准备阶段value值是0
public static final int value=123；//准备阶段value的值是123
```

**<font color=pink size=4>解析</font>**

##### 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
##### 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存无关，引用的目标不一定加载到内存中。。各种虚拟机四线的内存布局可以不同，但是他们接受到的符号引用是一致的，因为符号引用的字面量形式明确的定义在Java虚拟机规范的Class文件格式中。

##### 直接引用：直接引用是直接指向目标引用的指针、相对偏移量或者一个能间接定位到目标的句柄。直接引用是和虚拟机实现的布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

###### 类和接口的解析
假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或者接口C的直接引用，那虚拟机完成需要完成整个解析的过程需要以下3个步骤：
- 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C
- 如果是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似[Ljava/lang/Integer]的形式，就会按照第一点的形式加载数组元素类型。
- 如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或者接口了，但在解析完成之前还要进行符号验证，确认D是否具备对C的访问权限。如果没有权限，将会抛出异常。
###### 字段解析
要解析一个未被解析过的字段符号引用，首先将会对字段表内的class_index项中索引的CONSIANT_Class_info符号引用进行解析，也就是字段所属的类或者接口的符号引用。
1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的片段，则返回这个字段的直接引用，查找结束。
2. 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单的名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。
3. 否则 如果C不是java.lang.object的话，将会按照继承关系从下往上递归搜索其父类。如果父类找到了匹配的简单名称和字符串，则返回直接引用。
4. 否则，查找失败，抛出异常。
###### 类方法解析
类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类和接口的符号引用。
1. 类方法和接口方法符号的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出异常。
2. 如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在父类中敌对查找，如果有相匹配的，则查找结束。
4. 否则，在类C的实现的接口列表及他们的父接口之中递归查找是否有相匹配的方法，如果有匹配的方法，说明类C是一个抽象类，查找结束，抛出异常。
5. 否则，则抛出异常。
6. 查找过程返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出异常。
###### 接口方法解析
 接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机会按照一下步骤进行后续的接口方法搜索。
1. 如果在接口方法表中发现class_index中的索引C是个类而不是个接口，就直接抛出异常。
2. 否则，在接口C中查找是否有匹配的方法，如果有，则直接返回这个方法的引用。
3. 在接口的父接口中递归查找是否有简单名称和描述符与之相匹配的方法，如果有，则返回其直接引用。
4. 否则，宣告方法查找失败。
接口的所有方法都是public的，所以不存在权限问题。

**<font color=pink size=4>初始化</font>**
##### 在前面阶段，除了加载阶段用户应用程序可以通过自定义类加载器参与以外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才开始真正的执行类定义中的Java程序代码。
##### 在准备阶段，变量已经赋过一次要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。
- [ ] <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器手机的顺序是由语句在源文件中出源文件出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
- [ ] <clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。
- [ ] 由于父类的<clinit>()方法限制性，也就意味着父类中定义的静态语句块要先优于子类的变量赋值操作。
- [ ] 接口中不能使用静态代码块，但仍然有变量的赋值操作，因此接口和类一样都会生成<clinit>方法。==但接口与类不相同的是，执行接口的clinit>方法不需要先执行父接口的<clinit>方法,只要父接口中定义的变量在使用的时候，父接口才会初始化。==
- [ ] <clinit>方法对于类或者接口来说并不是必须的，如果一个类中没有静态语句块，也没有变量的赋值操作，那么编译器可以不为这个类生成<clinit>方法.
- [ ] 虚拟机会保证一个类的<clinit>方法在多线程环境中被正确的加锁、同步，如果多个线程同时初始化一个类，那么只有一个线程去执行这个类的<clinit>（）方法。
#### 四、类加载器
 ##### 虚拟机设计团队把类加载阶段中“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为类加载器。
##### 类与类加载器
  类加载器虽然只用于实现类的加载动作，但他在Java程序起到的作用却远远不限于类加载阶段。对于任意一个类，都需要加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。即：比较这两个类是否相等，只有在两个类都是同一个类加载的前提下才有意义。