 ### GC
[toc]
#### 判断对象已死
垃圾回收，就是将已经分配出去的但却不再使用的内存回收回来，一遍能再次分配。那么关键的问题就是，如何判断一个对象已经死亡？那么有以下两种方法，即引用计数算法好和可达性分析算法。
##### 引用计数算法
  它的做法是给每一个对象添加一个计数器，用来统计对象的引用个数，一旦某个对象的引用的计数器为0，就说明该对象已经死亡，即便可以被回收了。具体实现如下：
  
如果一个引用，被赋予了一个对象，那么该对象的引用的计数器就会加一，如果某一对象的引用，被赋予其他值，那么这个计数器就会减一。也就是说，我们要截获所有引用的更新操作，并且相应的增减目标对象的引用计数器。

缺点：①需要额外的存储空间来存储计数器
      ②无法处理循环使用的对象。例如如果a和b互相引用，除此之外没有其他对象指向a或者指向b,在引用计数器的心中，这两个对象还活着，但实际上，他们已经死了。
##### 可达性分析
这个算法的实质在于将一系列GC Roots作为初始的对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并且将其加入该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。
什么是GCRoots呢？我们暂时可以理解为堆外指向堆内的引用，一般而言，GCRoots包括以下几种：

1.JAVA方法栈帧中的局部变量。
2.已加载类的静态变量
3.JNI handles（本地方法栈中的引用）
4.已启动但并未停止的JAVA线程。
缺点：在多线程的情况下。其他线程可能会更新已访问过对象的引用，从而造成误报（将引用设置为null)或者漏报(将引用设置为未被访问过的对象)。
误报只会损失Java虚拟机部分垃圾回收的机会，漏报组会导致回收事实上仍被引用的对象内存，则很有可能会直接导致Java虚拟机崩溃。
##### stop_the_world 以及安全点
Java虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收，这也造成了垃圾回收所谓的暂停时间。
当Java虚拟机收到stop_the_world请求时，它便会等待所有线程都到达安全点，才允许请求stop_the_world的线程进行独占的工作。

安全点：安全点的初始目的并不是为了让其他线程停下，而是找到一个稳定的执行状态。在这个状态下，Java虚拟机的堆栈不会发生变化。

由于本地代码需要通过JNI的API完成上述三个操作，因此Java虚拟机仅需在API的入口处进行安全点检测，测试是否有其他线程请求停留在安全点里，便可以在必要时挂起线程。

#### 垃圾回收的三种方式
##### 标记清除
把死亡内存标记为空闲内存，并记录在一个空闲列表之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的内存。

优点：原理简单
缺点：造成内存碎片 
      分配效率低
     
##### 标记整理

把存活的对象聚集到内存区域的起始位置，从而留下一块连续的内存空间，这种算法能够解决内存的碎片化问题。但代价是标记整理算法的性能开销。



##### 复制

内存区域划成两等分，分别用两个指针from和to来维护，并且只能用form的指针来分配内存，当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域，并且交换from和to指针指向的内容。复制这种回收方式同样能解决碎片化的问题，但是缺点是堆空间的效率低下。

#### 分代回收思想
##### java虚拟机中的堆分配                             
java虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为Eden区和两个相同的survivor区。
默认情况下，Java虚拟机采取的是一种动态分配的策略，根据对象生成的速率和survivor区的使用情况来动态调整Eden区和survivor区的比例。但需要的注意的是，有一个survivor区域会一直为空，因此比例越低，浪费的堆空间会越高。
![image](http://i.caigoubao.cc/625949/TIM%E5%9B%BE%E7%89%8720190922155626.png)

当我们调用new指令时，就会在Eden区划分一块作为内存的存储空间，因为堆线程是共享的，因此在这里面划分空间是需要进行同步的。Java虚拟机为了解决两个线程公用一块内存的问题，采用了TLAB。具体来说，就是每个线程会向Java虚拟机中申请一块连续的内存，作为线程私有的TLAB。这个操作需要加锁，线程需要维护两个指针（实际上需要的可能更多),一个指向TLAB中空余内存的起始位置，一个指向TLAB末尾。接下来的new指令，便可以直接通过指针的加法来实现，即把之内空余内存位置的指针加上所有请求的字节数。如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB已经没有足够饿空间来满足本次新建操作。这个时候，便需要当前线程重新申请TLAB。
当Eden区空间耗尽了怎么办？这个时候Java虚拟机会出发一次内存Minor Gc,来收集新生代的垃圾。存活下来的对象，则会被送到Surviors区。
新生代共有两个survivor区，我们分别用from和to来替代。其中to指向的survior区是空的。


发生Minor GC时，Eden区和from指向的survior区中存活的对象会被复制到to指向的Survior区中，然后交换from和to指针，确保下一次进行Minor GC时候，to指向的survior区还是空的。

Java虚拟机会记录survior区中的对象一共被复制了几次。如果一个对象被复制的次数为15，那么对该对象将被晋升至老年代。另外，如果单个Survior区已经被占用了50%，那么较高复制了次数的对象也会被晋升至老年代.

当发生Minor GC时，我们应用了标记——复制算法，将Survior去中的老存活对象晋升到老年代，然后将剩下的存活对象和和Eden的存活对复制到另一个Survior区中。理想情况下，Eden区中的对象已经死完了，需要复制的对象极少，因此采用这种复制标记算法的效果极好。


MinorGC的另外一个好处是不用对整个堆进行垃圾回收。但是存在的问题是，老年代可能会引用新生代的对象，在标记寻获对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代的引用，这些对象也可以被看做GCRoots。
##### 卡表
HotSpot给出的解决方案是卡表，该技术是将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表所指向的卡是否存在指向新生代对象的引用。如果可能存在，我们就认为这个卡是脏的。

在进行Minor GC的时候，我们便可一不用扫描整个老年代，只用把这些脏卡加到Minor GC的GC Roots里，然后将这些脏卡的标识位清零。
