#### 设计模式简介
设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。实用设计模式是为了重用代码，让代码更容易被他人理解、保证代码的可靠性。设计模式主要是基于以下的面向对象设计原则：
- 对接口编程而不是对实现编程
- 优先使用对象组合而不是继承
[toc]
#### 设计模式的类型
 设计模式可以分为三大类：创建者模式、结构者模式和行为者模式。
###### 创建者模式
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更灵活。
- ##### 工厂模式
工厂模式是Java中最常用的设计模式之一。这种类型的设计模式属于创建者模式。它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

介绍：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

何时使用：我们明确的计划不同条件下创建不同实例时。
- ##### 抽象工厂模式
抽象工厂模式是围绕一个超级工厂的=创建其他工厂。该超级工厂又称为其他工厂的工厂，这种类型的设计模式属于创建者模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显示指定他们的类。每个生成的工厂都能按照工厂模式提供对象。

何时使用：系统的产品有多个产品族，而系统只消费其中某一族的产品。
- ##### 单例模式
单例模式属于创建者模式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个对象提供了访问其唯一对象的方式，可以直接访问，不需要实例化该对象。

何时使用：当你想控制实例数目，节省系统资源的时候
###### 单例模式的几种实现方式：
1.懒汉式：线程不安全

```
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
```
2.懒汉式，线程安全

```
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
```
优点：第一次调用时才初始化，避免内存浪费
缺点：必须加锁synchronize才能保证单例，但加锁会影响效率。
3.饿汉式
优点：

```
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}
```
4.双检锁/双重校验锁

```
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  //是否被初始化
        synchronized (Singleton.class) {  
        if (singleton == null) {  //再次检查变量是否已经被初始化(如果还没初始化就初始化一个对象)
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}
```
5.登记式/静态内部类

```
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}
```
6.枚举

```
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
```
- ##### 建造者模式
建造者模式使用多个简单的对象一步一步构建一个复杂的对象。这种类型的设计模式属于创建者模式，它提供了一种创建对象的最佳方式。

何时使用：一些基本部件不会变，而其组合经常变化的时候。
- ##### 原型模式
原型模式是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建者模式，它提供了一种创建对象的最佳方式。

意图：用原形实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
###### 结构者模式：
这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象会的新功能的方式。
- ##### 适配者模式
适配者模式是作为两个不兼容的接口之间的桥梁，这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

何时使用：1.系统需要使用先有的类，而此类的接口不符合系统的需要。2.想要建立一个可以重复使用的类，用于和一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。3.通过接口转换，将一个类插入另一个类系中。
- ##### 桥接模式
桥接适用于把抽象化和实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，他通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

何时使用：实现系统可能有多个角度分类，每一种角度都可能发生变化。
 
如何解决：把这种角度分类分离出来，让他们独立变化，减少他们之间的耦合。
- ##### 过滤器模式
这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把他们连接起来。
- ##### 组合模式
组合模式，又叫部分整体模式，是用于把一组相似的对象当做一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次，这种类型的设计模式属于结构者模式，它创建了对象组的树形结构。
- ##### 装饰器模式
- ##### 外观模式
- ##### 享元模式
- ##### 代理模式
###### 行为型模式：
这些设计模式特别关注对象之间的通信。
- ##### 责任链模式
- ##### 命令模式
- ##### 解释器模式
- ##### 迭代器模式
- ##### 中介者模式
- ##### 备忘录模式
- ##### 观察者模式
- ##### 状态模式
- ##### 空对象模式
- ##### 策略模式
- ##### 模板模式
- ##### 访问者模式
#### 设计模式的六大原则
①开闭原则
②里世代换原则
③依赖翻转原则
④接口隔离原则
⑤迪米特原则：又称最少知道原则
⑥合成复用原则