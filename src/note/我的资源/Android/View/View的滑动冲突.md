[toc]
#### 造成滑动冲突的原因
  在界面中只要内外两层同时可以滑动，这个时候就会产生滑动冲突。
 ##### 常见的滑动冲突的场景：
 ###### 场景一：外部滑动方向和内部不一致
 ###### 场景二：外部滑动方向和内部一致
 ###### 场景三：上面两种形式的嵌套
 ##### 滑动的处理规则
 ###### 场景一：
 当用户左右滑动时，需要让外部的View拦截点击事件，当用户上下滑动时，需要让内部View点击拦截事件。即根据水平滑动还是竖直滑动判断到底是 由谁来拦截事件。
 ###### 场景二：
 它无法根据滑动的角度、距离差以及速度差来判断，但是这个时候一般都能在业务上找到突破点，比如业务上有规定：当处于某种状态时需要外部View相应用户的滑动，而处于另一种状态时则需要内部View来响应View的滑动。
 ###### 场景三：
 同样是只能在业务上找到突破点。
 ##### 滑动冲突的解决方式：
 根据滑动的距离差来进行判断，这个距离就是所谓的滑动规则。Viewpager已经帮助我们做了相应的拦截，针对别的View的滑动冲突，我们有两种解决方式：内部拦截法和外部拦截发。
 ###### 外部拦截法
 外部拦截是指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，不需要此事件就不拦截，这样就可以解决滑动冲突的问题。外部拦截法需要重写父容器的onInterceptTouchEvent方法。在内部做相应的拦截既可。
 
 
 在onInterceptTouchEvent方法中，ACTION_DOWN和ACTION_UP必须返回false，因为父容器一旦拦截了ACTION_DOWN事件，后续的ACTION_MOVE和ACTION_UP事件都会直接交给父容器处理，ACTION_UP事件则本身没有太大的意义。
 
 ACTION_MOVE可以根据需要决定是否会拦截，若拦截则返回true，否则则返回false。
 
 ##### 内部拦截法
 
 内部拦截是指父容器不拦截任何事件，全部交给子元素处理，如果子元素需要消耗这个事件则会被直接消耗掉，否则就会交给父容器进行处理，这种方法和安卓中的分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。