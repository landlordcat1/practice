##### 快速排序是冒泡排序的改进版，也是一种比较好的内排序
##### 主要思想：
##### 1.在待排序的元素任取一个元素作为基准（通常是选择第一个元素，但选择的最终方法是从待排序中随机选取一个作为基准），称为基准元素；
##### 2.将待排序的元素进行分区，比基准元素大的放在他的右边，比其小的放在它 的左边。
##### 3.对左右两个分区重复以上步骤直到所有元素都是有序的。

```
public class QuickSort {

    public static void quickSort(int arr[],int _left,int _right){
        int left = _left;
        int right = _right;
        int temp = 0;
        if(left <= right){   //待排序的元素至少有两个的情况
            temp = arr[left];  //待排序的第一个元素作为基准元素
            while(left != right){   //从左右两边交替扫描，直到left = right

                while(right > left && arr[right] >= temp)  
                     right --;        //从右往左扫描，找到第一个比基准元素小的元素
                  arr[left] = arr[right];  //找到这种元素arr[right]后与arr[left]交换

                while(left < right && arr[left] <= temp)
                     left ++;         //从左往右扫描，找到第一个比基准元素大的元素
                  arr[right] = arr[left];  //找到这种元素arr[left]后，与arr[right]交换

            }
            arr[right] = temp;    //基准元素归位
            quickSort(arr,_left,left-1);  //对基准元素左边的元素进行递归排序
            quickSort(arr, right+1,_right);  //对基准元素右边的进行递归排序
        }        
    }
```
##### 选择基准的方式：
##### （1）固定位置
思想：取序列的最后一个或者第一个元素为基准
##### （2）随机选取基准
思想：取待排序的任何一个元素为基准
###### 引入的原因：在待排序是部分有序的时候，固定选取基准使快排效率低下，要缓解这种情况，就引入了随机选取基准
##### （3）三数取中
具体思想：对待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。

即：采用三数取中，并用0下标元素存储枢轴。
##### 优化一：
当待排序序列的长度分割到一定大小后，使用插入排序
###### 原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排截止范围：待排序序列长度N = 10，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形。摘自《数据结构与算法分析》Mark Allen Weiness 著
##### 优化二：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割

##### 优化三：优化递归操作