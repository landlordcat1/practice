### 运行时数据区域
#### Java虚拟机所管理的内存将会包括以下几个运行时数据区域：程序计数器，JAVA虚拟机栈，本地方法栈，Java方法堆和方法区。
##### 线程私有的是程序计数器，本地方法栈和虚拟机栈
##### 线程共享的是JAVA堆和方法区
##### 程序计数器：可以看做是线程执行的字节码的行号（指令地址）指示器。生命周期随线程启动产生，线程结束而死亡。
##### JAVA虚拟机栈：也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是JAVA方法执行的内存模型：每个方法在执行的过程中，都会创建一个栈帧，里面用于存储局部变量表、操作数栈、动态链接和方法出口。每一方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从出栈到入栈的过程。局部变量表中所需要的内存在Java编译时完成分配，并且在运行期间不会发生改变。
##### 本地方法栈：本地方法栈与虚拟机栈的不同之处在于，虚拟机栈为Java方法服务，而本地方法栈为虚拟机使用到的Native方法服务。
##### Java堆：是虚拟机内存管理的内存中最大的一块。Java是被所有线程共享的一块内存区域。Java堆中存放的是内存实例。Java堆也是GC垃圾回收的主要区域。
##### 方法区（与类共存亡）：是线程共享的一块区域。存储已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。方法区实现内存分配的效率很低。
##### 运行时常量池：运行时常量池是方法区的一部分用于生成编译时期生成的各种字面量和符号引用。具备动态性。
##### 直接内存：直接内存的分配不会受到Java堆的限制，存储的native方法所需要的东西。
### 对象的创建过程
#### 当虚拟机遇到一条new指令时

###### ①首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个来是否被解析、加载和初始化过。
###### ②类加载完成之后，虚拟机将会给新生对象分配内存，对象所需的内存大小，在类加载完成之后就会被确定，有“指针碰撞”和“空闲列表”两种方式分配内存。为了解决并发问题，采用了TLAB和CAS匹配的方式。

###### ③虚拟机会将分配的内存初始化为零值。
###### ④对对象进行必要的设置。
#### 对象的内存布局
##### 对象的内存布局可以分为三个部分，对象头、实例数据和对齐填充。对象头包括两部分信息存储对象自身的实例数据和对象指向类元数据的指针。
#### 对象的访问定位
##### 采用句柄和直接指针的方式。
###### 句柄访问：Java堆中会划分出来一块句柄池，用来存储句柄的引用，句柄主要分为两部分，一部分为对象的实例数据，另一部分是类型的各自指针。
###### 直接指针：reference中存的直接就是对象的地址。直接指针访问的速度更快。